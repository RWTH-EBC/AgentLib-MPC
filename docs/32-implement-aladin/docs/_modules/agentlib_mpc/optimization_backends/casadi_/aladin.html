

<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>agentlib_mpc.optimization_backends.casadi_.aladin &mdash; agentlib_mpc 0.6.6 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/autodoc_pydantic.css" />

  
      <script src="../../../../_static/jquery.js"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
      <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
      <script src="../../../../_static/doctools.js"></script>
      <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            agentlib_mpc
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../PackageReference.html">Package Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">agentlib_mpc</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../optimization_backends.html">agentlib_mpc.optimization_backends</a></li>
      <li class="breadcrumb-item active">agentlib_mpc.optimization_backends.casadi_.aladin</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for agentlib_mpc.optimization_backends.casadi_.aladin</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">casadi</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ca</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.data_structures.admm_datatypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">VariableReference</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.data_structures.casadi_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">DiscretizationMethod</span><span class="p">,</span>
    <span class="n">GUESS_PREFIX</span><span class="p">,</span>
    <span class="n">MPCInputs</span><span class="p">,</span>
    <span class="n">CasadiDiscretizationOptions</span><span class="p">,</span>
    <span class="n">SolverFactory</span><span class="p">,</span>
    <span class="n">OptParMXContainer</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.data_structures.mpc_datamodels</span><span class="w"> </span><span class="kn">import</span> <span class="n">MPCVariable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.models.casadi_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">CasadiParameter</span><span class="p">,</span> <span class="n">CasadiInput</span><span class="p">,</span> <span class="n">CasadiModel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.modules.dmpc.aladin</span><span class="w"> </span><span class="kn">import</span> <span class="n">aladin_datatypes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.optimization_backends.casadi_.admm</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">CasADiADMMBackend</span><span class="p">,</span>
    <span class="n">ADMMCollocation</span><span class="p">,</span>
    <span class="n">ADMMMultipleShooting</span><span class="p">,</span>
    <span class="n">CasadiADMMSystem</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.optimization_backends.casadi_.basic</span><span class="w"> </span><span class="kn">import</span> <span class="n">DirectCollocation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.optimization_backends.casadi_.core.VariableGroup</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">OptimizationVariable</span><span class="p">,</span>
    <span class="n">OptimizationParameter</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.optimization_backends.casadi_.core.discretization</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Discretization</span><span class="p">,</span>
    <span class="n">Results</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">agentlib_mpc.optimization_backends.casadi_.full</span><span class="w"> </span><span class="kn">import</span> <span class="n">FullSystem</span>


<div class="viewcode-block" id="CasadiALADINSystem"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.CasadiALADINSystem">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">CasadiALADINSystem</span><span class="p">(</span><span class="n">FullSystem</span><span class="p">):</span>
    <span class="n">local_couplings</span><span class="p">:</span> <span class="n">OptimizationVariable</span>
    <span class="n">multipliers</span><span class="p">:</span> <span class="n">OptimizationParameter</span>
    <span class="n">penalty_factor</span><span class="p">:</span> <span class="n">OptimizationParameter</span>

<div class="viewcode-block" id="CasadiALADINSystem.initialize"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.CasadiALADINSystem.initialize">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">CasadiModel</span><span class="p">,</span> <span class="n">var_ref</span><span class="p">:</span> <span class="n">aladin_datatypes</span><span class="o">.</span><span class="n">VariableReference</span>
    <span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">var_ref</span><span class="o">=</span><span class="n">var_ref</span><span class="p">)</span>

        <span class="n">coup_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">var_ref</span><span class="o">.</span><span class="n">couplings</span><span class="p">]</span>
        <span class="n">pure_outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">outputs</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coup_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outputs</span> <span class="o">=</span> <span class="n">OptimizationVariable</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span>
            <span class="n">denotation</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="n">pure_outs</span><span class="p">,</span>
            <span class="n">ref_list</span><span class="o">=</span><span class="n">var_ref</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">local_couplings</span> <span class="o">=</span> <span class="n">OptimizationVariable</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span>
            <span class="n">denotation</span><span class="o">=</span><span class="s2">&quot;local_couplings&quot;</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">coup_names</span><span class="p">],</span>
            <span class="n">ref_list</span><span class="o">=</span><span class="n">coup_names</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">multipliers</span> <span class="o">=</span> <span class="p">[</span><span class="n">coup</span><span class="o">.</span><span class="n">multiplier</span> <span class="k">for</span> <span class="n">coup</span> <span class="ow">in</span> <span class="n">var_ref</span><span class="o">.</span><span class="n">couplings</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span> <span class="o">=</span> <span class="n">OptimizationParameter</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span>
            <span class="n">denotation</span><span class="o">=</span><span class="s2">&quot;multipliers&quot;</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="n">CasadiInput</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">coup</span><span class="p">)</span> <span class="k">for</span> <span class="n">coup</span> <span class="ow">in</span> <span class="n">multipliers</span><span class="p">],</span>
            <span class="n">ref_list</span><span class="o">=</span><span class="n">multipliers</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">penalty_factor</span> <span class="o">=</span> <span class="n">OptimizationParameter</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span>
            <span class="n">denotation</span><span class="o">=</span><span class="s2">&quot;rho&quot;</span><span class="p">,</span>
            <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="n">CasadiParameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">aladin_datatypes</span><span class="o">.</span><span class="n">LOCAL_PENALTY_FACTOR</span><span class="p">)],</span>
            <span class="n">ref_list</span><span class="o">=</span><span class="p">[</span><span class="n">aladin_datatypes</span><span class="o">.</span><span class="n">LOCAL_PENALTY_FACTOR</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># add aladin terms to objective function</span>
        <span class="n">objective</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_ref</span><span class="o">.</span><span class="n">couplings</span><span class="p">)):</span>
            <span class="n">local_couplings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_couplings</span><span class="o">.</span><span class="n">full_symbolic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">multiplier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="o">.</span><span class="n">full_symbolic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">objective</span> <span class="o">+=</span> <span class="n">multiplier</span> <span class="o">*</span> <span class="n">local_couplings</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cost_function</span> <span class="o">+=</span> <span class="n">objective</span></div></div>


<div class="viewcode-block" id="ALADINDiscretization"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINDiscretization">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">ALADINDiscretization</span><span class="p">(</span><span class="n">Discretization</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">CasadiDiscretizationOptions</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensitivities_result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_variable</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sensitivities_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>

<div class="viewcode-block" id="ALADINDiscretization.get_aladin_registration"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINDiscretization.get_aladin_registration">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_aladin_registration</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mpc_inputs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">DM</span><span class="p">],</span> <span class="n">var_ref</span><span class="p">:</span> <span class="n">VariableReference</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="c1"># answer = ald.RegistrationA2C(</span>
        <span class="c1">#     coup_vars=...,</span>
        <span class="c1">#     local_solution=...,</span>
        <span class="c1"># )</span>
        <span class="n">guesses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_initial_guess</span><span class="p">(</span><span class="n">mpc_inputs</span><span class="p">)</span>
        <span class="n">mpc_inputs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">guesses</span><span class="p">)</span>
        <span class="n">nlp_inputs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">DM</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpc_inputs_to_nlp_inputs</span><span class="p">(</span><span class="o">**</span><span class="n">mpc_inputs</span><span class="p">)</span>

        <span class="n">local_solution</span> <span class="o">=</span> <span class="n">nlp_inputs</span><span class="p">[</span><span class="s2">&quot;x0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">opt_var_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_solution</span><span class="p">)</span>
        <span class="n">mpc_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nlp_outputs_to_mpc_outputs</span><span class="p">(</span>
            <span class="n">vars_at_optimum</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">opt_var_length</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_solution</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">mpc_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">mpc_output</span><span class="p">)</span>
        <span class="n">coup_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">result</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">var_ref</span><span class="o">.</span><span class="n">couplings</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">local_solution</span><span class="p">,</span> <span class="n">coup_vars</span></div>

<div class="viewcode-block" id="ALADINDiscretization.shift_opt_var"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINDiscretization.shift_opt_var">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">shift_opt_var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="n">current_optimum</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;guess_</span><span class="si">{</span><span class="n">den</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">var</span><span class="o">.</span><span class="n">opt</span> <span class="k">for</span> <span class="n">den</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpc_opt_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># if this is the first step, just return none</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">current_optimum</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">den</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpc_opt_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">den</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;guess_</span><span class="si">{</span><span class="n">den</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># skip if there are no variables of that type</span>
                <span class="k">continue</span>
            <span class="n">shift_by</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">prediction_horizon</span><span class="p">)</span>
            <span class="c1"># have to use the key guess_... here, as the _mpc_inputs_to_nlp_inputs</span>
            <span class="c1"># original implementation uses that, and we want to use that function</span>
            <span class="n">current_optimum</span><span class="p">[</span><span class="n">den</span><span class="p">]</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">horzcat</span><span class="p">(</span>  <span class="c1"># have to use guess here as</span>
                <span class="n">current_optimum</span><span class="p">[</span><span class="n">den</span><span class="p">][</span><span class="n">shift_by</span><span class="p">:],</span> <span class="n">current_optimum</span><span class="p">[</span><span class="n">den</span><span class="p">][</span><span class="o">-</span><span class="n">shift_by</span><span class="p">:]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mpc_inputs_to_nlp_inputs</span><span class="p">(</span><span class="o">**</span><span class="n">current_optimum</span><span class="p">)[</span><span class="s2">&quot;x0&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ALADINDiscretization.solve"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINDiscretization.solve">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpc_inputs</span><span class="p">:</span> <span class="n">MPCInputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Results</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the discretized trajectory optimization problem.</span>

<span class="sd">        Args:</span>
<span class="sd">            mpc_inputs: Casadi Matrices specifying the input of all different types</span>
<span class="sd">                of optimization parameters. Matrices consist of different variable rows</span>
<span class="sd">                and have a column for each time step in the discretization.</span>
<span class="sd">                There are separate matrices for each input type (as defined in the</span>
<span class="sd">                System), and also for the upper and lower boundaries of variables</span>
<span class="sd">                respectively.</span>


<span class="sd">        Returns:</span>
<span class="sd">            Results: The complete evolution of the states, inputs and boundaries of each</span>
<span class="sd">                variable and parameter over the prediction horizon, as well as solve</span>
<span class="sd">                statistics.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># todo get these from coordinator</span>
        <span class="n">regularization_parameter</span> <span class="o">=</span> <span class="mf">0.0015111114529828148</span>
        <span class="n">activation_margin</span> <span class="o">=</span> <span class="mf">0.0007901426386278718</span>

        <span class="c1"># collect and format inputs</span>
        <span class="n">guesses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_initial_guess</span><span class="p">(</span><span class="n">mpc_inputs</span><span class="p">)</span>
        <span class="n">mpc_inputs</span><span class="p">[</span><span class="n">aladin_datatypes</span><span class="o">.</span><span class="n">PRESCRIBED</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_variable</span>
        <span class="n">mpc_inputs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">guesses</span><span class="p">)</span>
        <span class="n">nlp_inputs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ca</span><span class="o">.</span><span class="n">DM</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpc_inputs_to_nlp_inputs</span><span class="p">(</span><span class="o">**</span><span class="n">mpc_inputs</span><span class="p">)</span>

        <span class="c1"># perform optimization</span>
        <span class="n">nlp_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="p">(</span><span class="o">**</span><span class="n">nlp_inputs</span><span class="p">)</span>
        <span class="n">debug_stats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_optimizer</span><span class="o">.</span><span class="n">stats</span><span class="p">()</span>
        <span class="n">debug_prescribed_input</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nlp_outputs_to_mpc_outputs</span><span class="p">(</span>
                <span class="n">vars_at_optimum</span><span class="o">=</span><span class="n">mpc_inputs</span><span class="p">[</span><span class="s2">&quot;prescribed&quot;</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="c1"># todo we are ignoring box constraints here. maybe that is the problem</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_constraints</span><span class="p">(</span><span class="n">nlp_output</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">nlp_inputs</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">])</span>
        <span class="n">active_constraints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_active_constraints</span><span class="p">(</span>
            <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
            <span class="n">lb</span><span class="o">=</span><span class="n">nlp_inputs</span><span class="p">[</span><span class="s2">&quot;lbg&quot;</span><span class="p">],</span>
            <span class="n">ub</span><span class="o">=</span><span class="n">nlp_inputs</span><span class="p">[</span><span class="s2">&quot;ubg&quot;</span><span class="p">],</span>
            <span class="n">act_margin</span><span class="o">=</span><span class="n">activation_margin</span><span class="p">,</span>  <span class="c1"># todo get from coordinator</span>
        <span class="p">)</span>

        <span class="c1"># get sensitivities</span>
        <span class="n">nlp_output</span><span class="p">[</span><span class="s2">&quot;lam_g&quot;</span><span class="p">][</span><span class="o">~</span><span class="n">active_constraints</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensitivities_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sensitivities_func</span><span class="p">(</span>
            <span class="n">opt_vars</span><span class="o">=</span><span class="n">nlp_output</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span>
            <span class="n">opt_pars</span><span class="o">=</span><span class="n">nlp_inputs</span><span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">],</span>
            <span class="n">local_constraint_multipliers</span><span class="o">=</span><span class="n">nlp_output</span><span class="p">[</span><span class="s2">&quot;lam_g&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">debug_jacobian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="p">[</span><span class="s2">&quot;J&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="p">[</span><span class="s2">&quot;J&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="p">[</span><span class="s2">&quot;J&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()[</span>
            <span class="n">active_constraints</span>
        <span class="p">]</span>
        <span class="c1"># todo look at hessian and also with regard to lam_g, maybe this is funky. Alternatively, look at gradient, whether there should be more to that, including constraints</span>
        <span class="n">original_hessian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">regularize_h</span><span class="p">(</span>
            <span class="n">original_hessian</span><span class="p">,</span> <span class="n">regularization_parameter</span>
        <span class="p">)</span>
        <span class="n">debug_sensitivities</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">debug_sensitivities</span><span class="p">[</span><span class="s2">&quot;jacobian_all&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">debug_jacobian</span>

        <span class="c1"># format and return solution</span>
        <span class="n">mpc_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nlp_outputs_to_mpc_outputs</span><span class="p">(</span><span class="n">vars_at_optimum</span><span class="o">=</span><span class="n">nlp_output</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remember_solution</span><span class="p">(</span><span class="n">mpc_output</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_solution</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">mpc_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">mpc_output</span><span class="p">)</span>

        <span class="c1"># todo the hessian of cooler is too big and I am missing box constraints I think</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_active_constraints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">constraints</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">act_margin</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a boolean array of constraints that are considered active.&quot;&quot;&quot;</span>
        <span class="c1"># Check if lb and ub have the same shape as constraints</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">constraints</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">lb</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">ub</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">),</span> <span class="s2">&quot;Constraints, lb, and ub must have the same shape&quot;</span>

        <span class="c1"># Create a boolean array to store active constraints</span>
        <span class="n">active_constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Check equality constraints</span>
        <span class="n">equality_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lb</span> <span class="o">==</span> <span class="n">ub</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">active_constraints</span><span class="p">[</span><span class="n">equality_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Check inequality constraints</span>
        <span class="n">inequality_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lb</span> <span class="o">&lt;</span> <span class="n">ub</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">active_upper</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">constraints</span> <span class="o">&lt;</span> <span class="n">act_margin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">inequality_mask</span>
        <span class="p">)</span>
        <span class="n">active_lower</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constraints</span> <span class="o">-</span> <span class="n">lb</span> <span class="o">&lt;</span> <span class="n">act_margin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">inequality_mask</span>
        <span class="p">)</span>
        <span class="n">active_constraints</span><span class="p">[</span><span class="n">active_upper</span> <span class="o">|</span> <span class="n">active_lower</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">active_constraints</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

<div class="viewcode-block" id="ALADINDiscretization.initialize"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINDiscretization.initialize">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">CasadiALADINSystem</span><span class="p">,</span> <span class="n">solver_factory</span><span class="p">:</span> <span class="n">SolverFactory</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the trajectory optimization problem, creating all symbolic</span>
<span class="sd">        variables of the OCP, the mapping function and the numerical solver.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_discretize</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_finished_discretization</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># self._aladin_modifications(system)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_nlp_in_out_mapping</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_solver</span><span class="p">(</span><span class="n">solver_factory</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_aladin_modifications</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">CasadiALADINSystem</span><span class="p">):</span>
        <span class="c1"># inject aladin coupling term</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">penalty_factor</span><span class="p">)</span>
        <span class="n">optvars</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">)</span>
        <span class="n">global_coupling</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">MX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s2">&quot;global_coupling&quot;</span><span class="p">,</span> <span class="n">optvars</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">par_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpc_opt_pars</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
            <span class="n">aladin_datatypes</span><span class="o">.</span><span class="n">PRESCRIBED</span><span class="p">,</span> <span class="n">OptParMXContainer</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">par_list</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">global_coupling</span><span class="p">)</span>
        <span class="n">coupling_cost</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ca</span><span class="o">.</span><span class="n">norm_2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span> <span class="o">-</span> <span class="n">global_coupling</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span> <span class="o">+=</span> <span class="n">coupling_cost</span>

        <span class="c1"># create functions for sensitivities</span>
        <span class="n">objective_gradient</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s2">&quot;obj_grad&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span><span class="p">,</span> <span class="n">optvars</span><span class="p">)</span>

        <span class="n">constraint_jacobian</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s2">&quot;cons_jac&quot;</span><span class="p">,</span> <span class="p">[])</span>

<div class="viewcode-block" id="ALADINDiscretization.create_nlp_in_out_mapping"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINDiscretization.create_nlp_in_out_mapping">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">create_nlp_in_out_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">CasadiALADINSystem</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function creating mapping functions between the MPC variables ordered</span>
<span class="sd">        by type (as defined in `declare_quantities` and the raw input/output</span>
<span class="sd">        vector of the CasADi NLP.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add penalty parameter</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">penalty_factor</span><span class="p">)</span>

        <span class="c1"># Concatenate nlp variables to CasADi MX vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_pars</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_pars</span><span class="p">)</span>
        <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_guess</span><span class="p">)</span>
        <span class="n">opt_vars_lb</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars_lb</span><span class="p">)</span>
        <span class="n">opt_vars_ub</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars_ub</span><span class="p">)</span>
        <span class="n">constraints_lb</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints_lb</span><span class="p">)</span>
        <span class="n">constraints_ub</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints_ub</span><span class="p">)</span>

        <span class="c1"># create empty lists to store all nlp inputs and outputs</span>
        <span class="n">mpc_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">aladin_inputs_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">mpc_input_denotations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mpc_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mpc_output_denotations</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Concatenate mpc outputs and their bounds to CasADi MX matrices</span>
        <span class="k">for</span> <span class="n">denotation</span><span class="p">,</span> <span class="n">opt_var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpc_opt_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># mpc opt vars</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">opt_var</span><span class="o">.</span><span class="n">var</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">horzcat</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">)</span>
            <span class="n">mpc_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="n">mpc_output_denotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">denotation</span><span class="p">)</span>

            <span class="c1"># their bounds and guess</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">horzcat</span><span class="p">(</span><span class="o">*</span><span class="n">opt_var</span><span class="o">.</span><span class="n">lb</span><span class="p">)</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">horzcat</span><span class="p">(</span><span class="o">*</span><span class="n">opt_var</span><span class="o">.</span><span class="n">ub</span><span class="p">)</span>
            <span class="n">guess</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">horzcat</span><span class="p">(</span><span class="o">*</span><span class="n">opt_var</span><span class="o">.</span><span class="n">guess</span><span class="p">)</span>
            <span class="n">mpc_inputs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">guess</span><span class="p">])</span>
            <span class="n">mpc_input_denotations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;lb_</span><span class="si">{</span><span class="n">denotation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;ub_</span><span class="si">{</span><span class="n">denotation</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">GUESS_PREFIX</span> <span class="o">+</span> <span class="n">denotation</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># Concatenate mpc inputs to CasADi MX matrices</span>
        <span class="k">for</span> <span class="n">denotation</span><span class="p">,</span> <span class="n">opt_par</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpc_opt_pars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">opt_par</span><span class="o">.</span><span class="n">var</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">horzcat</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">)</span>
            <span class="n">mpc_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="n">aladin_inputs_dict</span><span class="p">[</span><span class="n">denotation</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
            <span class="n">mpc_input_denotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">denotation</span><span class="p">)</span>

        <span class="c1"># inject aladin coupling term</span>
        <span class="n">global_coupling</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">MX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s2">&quot;global_coupling&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coupling_cost</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">ca</span><span class="o">.</span><span class="n">sumsqr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span> <span class="o">-</span> <span class="n">global_coupling</span><span class="p">)</span>
        <span class="n">original_objective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span> <span class="o">+=</span> <span class="n">coupling_cost</span>
        <span class="n">mpc_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">global_coupling</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_pars</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_pars</span><span class="p">,</span> <span class="n">global_coupling</span><span class="p">)</span>
        <span class="n">mpc_input_denotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aladin_datatypes</span><span class="o">.</span><span class="n">PRESCRIBED</span><span class="p">)</span>

        <span class="c1"># nlp inputs</span>
        <span class="n">nlp_inputs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt_pars</span><span class="p">,</span>
            <span class="n">initial_guess</span><span class="p">,</span>
            <span class="n">opt_vars_lb</span><span class="p">,</span>
            <span class="n">opt_vars_ub</span><span class="p">,</span>
            <span class="n">constraints_lb</span><span class="p">,</span>
            <span class="n">constraints_ub</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">nlp_input_denotations</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="s2">&quot;x0&quot;</span><span class="p">,</span> <span class="s2">&quot;lbx&quot;</span><span class="p">,</span> <span class="s2">&quot;ubx&quot;</span><span class="p">,</span> <span class="s2">&quot;lbg&quot;</span><span class="p">,</span> <span class="s2">&quot;ubg&quot;</span><span class="p">]</span>

        <span class="c1"># Mapping function that rearranges the variables for input into the NLP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mpc_inputs_to_nlp_inputs</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span>
            <span class="s2">&quot;mpc_inputs_to_nlp_inputs&quot;</span><span class="p">,</span>
            <span class="n">mpc_inputs</span><span class="p">,</span>
            <span class="n">nlp_inputs</span><span class="p">,</span>
            <span class="n">mpc_input_denotations</span><span class="p">,</span>
            <span class="n">nlp_input_denotations</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Mapping function that rearranges the output of the nlp and sorts</span>
        <span class="c1"># by denotation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nlp_outputs_to_mpc_outputs</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span>
            <span class="s2">&quot;nlp_outputs_to_mpc_outputs&quot;</span><span class="p">,</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">],</span>
            <span class="n">mpc_outputs</span><span class="p">,</span>
            <span class="p">[</span><span class="s2">&quot;vars_at_optimum&quot;</span><span class="p">],</span>
            <span class="n">mpc_output_denotations</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># create function to extract constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_constraints</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span>
            <span class="s2">&quot;constraints&quot;</span><span class="p">,</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_pars</span><span class="p">],</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;opt_vars&quot;</span><span class="p">,</span> <span class="s2">&quot;opt_pars&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;constraints&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># create functions for sensitivities</span>
        <span class="c1"># todo in some papers, gradient here includes dot product of jacobian error times lam_g</span>
        <span class="n">objective_gradient</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">original_objective</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">)</span>
        <span class="n">aladin_inputs_dict</span><span class="p">[</span><span class="s2">&quot;multipliers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">MX</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="o">*</span><span class="n">aladin_inputs_dict</span><span class="p">[</span><span class="s2">&quot;multipliers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>
        <span class="n">substituted_opt_pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpc_inputs_to_nlp_inputs</span><span class="p">(</span><span class="o">**</span><span class="n">aladin_inputs_dict</span><span class="p">)[</span><span class="s2">&quot;p&quot;</span><span class="p">]</span>
        <span class="n">objective_gradient_function</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span>
            <span class="s2">&quot;obj_grad&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_pars</span><span class="p">],</span> <span class="p">[</span><span class="n">objective_gradient</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">objective_gradient_lambda_zero</span> <span class="o">=</span> <span class="n">objective_gradient_function</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">,</span> <span class="n">substituted_opt_pars</span>
        <span class="p">)</span>
        <span class="n">constraint_jacobian</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">)</span>
        <span class="c1"># todo somehow find out how to check for inactive inequality constraints</span>
        <span class="n">constraint_multipliers</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">MX</span><span class="o">.</span><span class="n">sym</span><span class="p">(</span><span class="s2">&quot;cons_mult&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">hessian</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span>
            <span class="n">original_objective</span> <span class="o">+</span> <span class="n">constraint_multipliers</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># todo find out, if the box constraints should be included, or if we use 1s there, and why it is ones. Box constraints are not included in Engelmann implementation, but why</span>
        <span class="n">hessian_function</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span>
            <span class="s2">&quot;hessian_func&quot;</span><span class="p">,</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_pars</span><span class="p">,</span> <span class="n">constraint_multipliers</span><span class="p">],</span>
            <span class="p">[</span><span class="n">hessian</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">hessian_lambda_zero</span> <span class="o">=</span> <span class="n">hessian_function</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">,</span> <span class="n">substituted_opt_pars</span><span class="p">,</span> <span class="n">constraint_multipliers</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sensitivities_func</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span>
            <span class="s2">&quot;obj_grad&quot;</span><span class="p">,</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_pars</span><span class="p">,</span> <span class="n">constraint_multipliers</span><span class="p">],</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">opt_vars</span><span class="p">,</span>
                <span class="n">objective_gradient_lambda_zero</span><span class="p">,</span>
                <span class="n">constraint_jacobian</span><span class="p">,</span>
                <span class="n">hessian_lambda_zero</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;opt_vars&quot;</span><span class="p">,</span> <span class="s2">&quot;opt_pars&quot;</span><span class="p">,</span> <span class="s2">&quot;local_constraint_multipliers&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">matrix</span><span class="p">,</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">full_grid</span><span class="p">,</span> <span class="n">var_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_result_format</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_result_map</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span>
            <span class="s2">&quot;result_map&quot;</span><span class="p">,</span> <span class="n">mpc_inputs</span><span class="p">,</span> <span class="p">[</span><span class="n">matrix</span><span class="p">],</span> <span class="n">mpc_input_denotations</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;result&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">make_results_view</span><span class="p">(</span><span class="n">result_matrix</span><span class="p">:</span> <span class="n">ca</span><span class="o">.</span><span class="n">DM</span><span class="p">,</span> <span class="n">stats</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Results</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Results</span><span class="p">(</span>
                <span class="n">matrix</span><span class="o">=</span><span class="n">result_matrix</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">col_index</span><span class="p">,</span>
                <span class="n">grid</span><span class="o">=</span><span class="n">full_grid</span><span class="p">,</span>
                <span class="n">variable_grid_indices</span><span class="o">=</span><span class="n">var_grids</span><span class="p">,</span>
                <span class="n">stats</span><span class="o">=</span><span class="n">stats</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_create_results</span> <span class="o">=</span> <span class="n">make_results_view</span></div></div>


<div class="viewcode-block" id="ALADINCollocation"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINCollocation">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">ALADINCollocation</span><span class="p">(</span><span class="n">ALADINDiscretization</span><span class="p">,</span> <span class="n">DirectCollocation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Direct collocation discretization for ALADIN-based optimization.</span>

<span class="sd">    This class implements the direct collocation discretization scheme for ALADIN algorithm</span>
<span class="sd">    optimization problems. It handles discretization of continuous dynamics using</span>
<span class="sd">    collocation polynomials.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_discretize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sys</span><span class="p">:</span> <span class="n">CasadiALADINSystem</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a direct collocation discretization for ALADIN-based optimization.</span>

<span class="sd">        Args:</span>
<span class="sd">            sys: The system to be discretized</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Setup the polynomial base</span>
        <span class="n">collocation_matrices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_polynomial</span><span class="p">()</span>

        <span class="c1"># Shorthands</span>
        <span class="n">prediction_horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">prediction_horizon</span>
        <span class="n">timestep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">time_step</span>

        <span class="c1"># Initial State</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">initial_state</span><span class="p">)</span>
        <span class="n">current_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_var</span><span class="p">(</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">guess</span><span class="o">=</span><span class="n">initial_state</span>
        <span class="p">)</span>
        <span class="n">previous_control</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">last_control</span><span class="p">)</span>

        <span class="c1"># Parameters that are constant over the horizon</span>
        <span class="n">model_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">model_parameters</span><span class="p">)</span>
        <span class="n">control_rate_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">r_del_u</span><span class="p">)</span>
        <span class="n">aladin_penalty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">penalty_factor</span><span class="p">)</span>

        <span class="c1"># Formulate the NLP - loop over prediction horizon</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">prediction_horizon</span><span class="p">:</span>
            <span class="c1"># New NLP variable for the control</span>
            <span class="n">current_control</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_var</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">controls</span><span class="p">)</span>
            <span class="c1"># Penalty for control change between time steps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span> <span class="o">+=</span> <span class="n">timestep</span> <span class="o">*</span> <span class="n">ca</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">control_rate_weights</span><span class="p">,</span> <span class="p">(</span><span class="n">previous_control</span> <span class="o">-</span> <span class="n">current_control</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">previous_control</span> <span class="o">=</span> <span class="n">current_control</span>

            <span class="c1"># New parameter for inputs</span>
            <span class="n">disturbance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">non_controlled_inputs</span><span class="p">)</span>

            <span class="c1"># Perform inner collocation loop</span>
            <span class="n">opt_vars_inside_inner</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">algebraics</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">outputs</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">local_couplings</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">opt_pars_inside_inner</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">multipliers</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">constant_over_inner</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">controls</span><span class="p">:</span> <span class="n">current_control</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">non_controlled_inputs</span><span class="p">:</span> <span class="n">disturbance</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">model_parameters</span><span class="p">:</span> <span class="n">model_parameters</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">penalty_factor</span><span class="p">:</span> <span class="n">aladin_penalty</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">state_end</span><span class="p">,</span> <span class="n">constraints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collocation_inner_loop</span><span class="p">(</span>
                <span class="n">collocation</span><span class="o">=</span><span class="n">collocation_matrices</span><span class="p">,</span>
                <span class="n">state_at_beginning</span><span class="o">=</span><span class="n">current_state</span><span class="p">,</span>
                <span class="n">states</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
                <span class="n">opt_vars</span><span class="o">=</span><span class="n">opt_vars_inside_inner</span><span class="p">,</span>
                <span class="n">opt_pars</span><span class="o">=</span><span class="n">opt_pars_inside_inner</span><span class="p">,</span>
                <span class="n">const</span><span class="o">=</span><span class="n">constant_over_inner</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Increment loop counter and time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pred_time</span> <span class="o">=</span> <span class="n">timestep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>

            <span class="c1"># New NLP variables at end of interval</span>
            <span class="n">next_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_var</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>

            <span class="c1"># Add continuity constraint</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">next_state</span> <span class="o">-</span> <span class="n">state_end</span><span class="p">,</span> <span class="n">gap_closing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Add collocation constraints</span>
            <span class="k">for</span> <span class="n">constraint</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="o">*</span><span class="n">constraint</span><span class="p">)</span>

            <span class="c1"># Update current state for next interval</span>
            <span class="n">current_state</span> <span class="o">=</span> <span class="n">next_state</span>

<div class="viewcode-block" id="ALADINCollocation.initialize"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINCollocation.initialize">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">CasadiALADINSystem</span><span class="p">,</span> <span class="n">solver_factory</span><span class="p">:</span> <span class="n">SolverFactory</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the trajectory optimization problem, creating all symbolic</span>
<span class="sd">        variables of the OCP, the mapping function and the numerical solver.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_stage_function</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">system</span><span class="o">=</span><span class="n">system</span><span class="p">,</span> <span class="n">solver_factory</span><span class="o">=</span><span class="n">solver_factory</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ALADINMultipleShooting"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINMultipleShooting">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">ALADINMultipleShooting</span><span class="p">(</span><span class="n">ALADINDiscretization</span><span class="p">,</span> <span class="n">ADMMMultipleShooting</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multiple shooting discretization for ALADIN-based optimization.</span>

<span class="sd">    This class implements the multiple shooting discretization scheme for ALADIN algorithm</span>
<span class="sd">    optimization problems. It handles discretization of continuous dynamics, addition of</span>
<span class="sd">    continuity constraints, and ALADIN-specific objective augmentation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_discretize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sys</span><span class="p">:</span> <span class="n">CasadiALADINSystem</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a multiple shooting discretization for ALADIN-based optimization.</span>

<span class="sd">        This method implements the multiple shooting discretization scheme for ALADIN.</span>
<span class="sd">        It handles:</span>
<span class="sd">        1. State continuity across shooting intervals</span>
<span class="sd">        2. Local coupling variables with their multipliers</span>
<span class="sd">        3. Integration of system dynamics</span>
<span class="sd">        4. Objective function construction including ALADIN terms</span>

<span class="sd">        Args:</span>
<span class="sd">            sys (CasadiALADINSystem): The system to be discretized, containing states,</span>
<span class="sd">                controls, and ALADIN-specific variables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract key parameters</span>
        <span class="n">prediction_horizon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">prediction_horizon</span>
        <span class="n">timestep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">time_step</span>
        <span class="n">integration_options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;t0&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;tf&quot;</span><span class="p">:</span> <span class="n">timestep</span><span class="p">}</span>

        <span class="c1"># Initialize state trajectory</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">initial_state</span><span class="p">)</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_var</span><span class="p">(</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">guess</span><span class="o">=</span><span class="n">initial_state</span>
        <span class="p">)</span>

        <span class="c1"># Initialize control input</span>
        <span class="n">previous_control</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">last_control</span><span class="p">)</span>

        <span class="c1"># Add time-invariant parameters</span>
        <span class="n">control_rate_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">r_del_u</span><span class="p">)</span>
        <span class="n">model_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">model_parameters</span><span class="p">)</span>
        <span class="n">aladin_penalty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">penalty_factor</span><span class="p">)</span>

        <span class="c1"># Create system integrator</span>
        <span class="n">dynamics_integrator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_ode</span><span class="p">(</span>
            <span class="n">sys</span><span class="p">,</span> <span class="n">integration_options</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">integrator</span>
        <span class="p">)</span>

        <span class="c1"># Perform multiple shooting discretization</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">prediction_horizon</span><span class="p">):</span>
            <span class="c1"># 1. Handle control inputs and their rate penalties</span>
            <span class="n">current_state</span> <span class="o">=</span> <span class="n">next_state</span>
            <span class="n">current_control</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_var</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">controls</span><span class="p">)</span>
            <span class="n">control_rate_penalty</span> <span class="o">=</span> <span class="n">timestep</span> <span class="o">*</span> <span class="n">ca</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="n">control_rate_weights</span><span class="p">,</span> <span class="p">(</span><span class="n">previous_control</span> <span class="o">-</span> <span class="n">current_control</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span> <span class="o">+=</span> <span class="n">control_rate_penalty</span>
            <span class="n">previous_control</span> <span class="o">=</span> <span class="n">current_control</span>

            <span class="c1"># 2. Add optimization variables for current shooting interval</span>
            <span class="n">disturbance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">non_controlled_inputs</span><span class="p">)</span>
            <span class="n">algebraic_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_var</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">algebraics</span><span class="p">)</span>
            <span class="n">output_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_var</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">outputs</span><span class="p">)</span>

            <span class="c1"># 3. Add ALADIN coupling variables and multipliers</span>
            <span class="n">local_coupling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_var</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">local_couplings</span><span class="p">)</span>
            <span class="n">multipliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_par</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">multipliers</span><span class="p">)</span>

            <span class="c1"># 4. Construct stage-wise optimization problem</span>
            <span class="n">stage_arguments</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1"># variables</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">current_state</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">algebraics</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">algebraic_vars</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">local_couplings</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">local_coupling</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">output_vars</span><span class="p">,</span>
                <span class="c1"># parameters</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">multipliers</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">multipliers</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">controls</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">current_control</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">non_controlled_inputs</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">disturbance</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">model_parameters</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">model_parameters</span><span class="p">,</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">penalty_factor</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">aladin_penalty</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">stage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stage_function</span><span class="p">(</span><span class="o">**</span><span class="n">stage_arguments</span><span class="p">)</span>

            <span class="c1"># 5. Integrate system dynamics</span>
            <span class="n">integration_result</span> <span class="o">=</span> <span class="n">dynamics_integrator</span><span class="p">(</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">current_state</span><span class="p">,</span>
                <span class="n">p</span><span class="o">=</span><span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span>
                    <span class="n">current_control</span><span class="p">,</span>
                    <span class="n">local_coupling</span><span class="p">,</span>
                    <span class="n">disturbance</span><span class="p">,</span>
                    <span class="n">model_parameters</span><span class="p">,</span>
                    <span class="n">algebraic_vars</span><span class="p">,</span>
                    <span class="n">output_vars</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>

            <span class="c1"># 6. Add continuity constraints</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pred_time</span> <span class="o">=</span> <span class="n">timestep</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">next_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_opt_var</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">next_state</span> <span class="o">-</span> <span class="n">integration_result</span><span class="p">[</span><span class="s2">&quot;xf&quot;</span><span class="p">],</span> <span class="n">gap_closing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># 7. Add objective contribution from stage</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objective_function</span> <span class="o">+=</span> <span class="n">stage</span><span class="p">[</span><span class="s2">&quot;cost_function&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">timestep</span>

            <span class="c1"># 8. Add model constraints</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span>
                <span class="n">stage</span><span class="p">[</span><span class="s2">&quot;model_constraints&quot;</span><span class="p">],</span>
                <span class="n">lb</span><span class="o">=</span><span class="n">stage</span><span class="p">[</span><span class="s2">&quot;lb_model_constraints&quot;</span><span class="p">],</span>
                <span class="n">ub</span><span class="o">=</span><span class="n">stage</span><span class="p">[</span><span class="s2">&quot;ub_model_constraints&quot;</span><span class="p">],</span>
            <span class="p">)</span>

<div class="viewcode-block" id="ALADINMultipleShooting.initialize"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.ALADINMultipleShooting.initialize">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system</span><span class="p">:</span> <span class="n">CasadiALADINSystem</span><span class="p">,</span> <span class="n">solver_factory</span><span class="p">:</span> <span class="n">SolverFactory</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the trajectory optimization problem, creating all symbolic</span>
<span class="sd">        variables of the OCP, the mapping function and the numerical solver.</span>

<span class="sd">        Args:</span>
<span class="sd">            system: The system to be discretized</span>
<span class="sd">            solver_factory: Factory to create the numerical solver</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_stage_function</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">system</span><span class="o">=</span><span class="n">system</span><span class="p">,</span> <span class="n">solver_factory</span><span class="o">=</span><span class="n">solver_factory</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="regularize_h"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.regularize_h">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">regularize_h</span><span class="p">(</span><span class="n">hessian</span><span class="p">,</span> <span class="n">reg_param</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Regularize a Hessian matrix to ensure it is positive definite and symmetric.</span>

<span class="sd">    Args:</span>
<span class="sd">        hessian: The Hessian matrix to regularize</span>
<span class="sd">        reg_param: Regularization parameter (minimum eigenvalue)</span>

<span class="sd">    Returns:</span>
<span class="sd">        H_reg: Regularized, symmetric Hessian matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure matrix is symmetric before eigendecomposition</span>
    <span class="n">hessian</span> <span class="o">=</span> <span class="p">(</span><span class="n">hessian</span> <span class="o">+</span> <span class="n">hessian</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># Eigenvalue decomposition of the Hessian</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">hessian</span><span class="p">)</span>

    <span class="c1"># Take absolute value of eigenvalues</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="c1"># Modify zero and too small eigenvalues (regularization)</span>
    <span class="n">e</span><span class="p">[</span><span class="n">e</span> <span class="o">&lt;=</span> <span class="n">reg_param</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_param</span>

    <span class="c1"># Regularization for small stepsize</span>
    <span class="n">H_reg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">@</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1"># Final symmetry enforcement</span>
    <span class="n">H_reg</span> <span class="o">=</span> <span class="p">(</span><span class="n">H_reg</span> <span class="o">+</span> <span class="n">H_reg</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">H_reg</span></div>


<div class="viewcode-block" id="CasADiALADINBackend"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.CasADiALADINBackend">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">CasADiALADINBackend</span><span class="p">(</span><span class="n">CasADiADMMBackend</span><span class="p">):</span>
    <span class="n">discretization</span><span class="p">:</span> <span class="n">ALADINDiscretization</span>

    <span class="n">system_type</span> <span class="o">=</span> <span class="n">CasadiALADINSystem</span>
    <span class="n">discretization_types</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">DiscretizationMethod</span><span class="o">.</span><span class="n">collocation</span><span class="p">:</span> <span class="n">ALADINCollocation</span><span class="p">,</span>
        <span class="n">DiscretizationMethod</span><span class="o">.</span><span class="n">multiple_shooting</span><span class="p">:</span> <span class="n">ALADINMultipleShooting</span><span class="p">,</span>
    <span class="p">}</span>

<div class="viewcode-block" id="CasADiALADINBackend.get_aladin_registration"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.CasADiALADINBackend.get_aladin_registration">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_aladin_registration</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">current_vars</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">MPCVariable</span><span class="p">],</span> <span class="n">now</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="n">mpc_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_current_mpc_inputs</span><span class="p">(</span><span class="n">agent_variables</span><span class="o">=</span><span class="n">current_vars</span><span class="p">,</span> <span class="n">now</span><span class="o">=</span><span class="n">now</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretization</span><span class="o">.</span><span class="n">get_aladin_registration</span><span class="p">(</span>
            <span class="n">mpc_inputs</span><span class="p">,</span> <span class="n">var_ref</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">var_ref</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CasADiALADINBackend.shift_opt_var"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.CasADiALADINBackend.shift_opt_var">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">shift_opt_var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretization</span><span class="o">.</span><span class="n">shift_opt_var</span><span class="p">()</span></div>

<div class="viewcode-block" id="CasADiALADINBackend.set_global_variable"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.CasADiALADINBackend.set_global_variable">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_global_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="n">var_</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">vertcat</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discretization</span><span class="o">.</span><span class="n">global_variable</span> <span class="o">=</span> <span class="n">var_</span></div>

<div class="viewcode-block" id="CasADiALADINBackend.get_sensitivities"><a class="viewcode-back" href="../../../../code/agentlib_mpc.optimization_backends.casadi_.html#agentlib_mpc.optimization_backends.casadi_.aladin.CasADiALADINBackend.get_sensitivities">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_sensitivities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">aladin_datatypes</span><span class="o">.</span><span class="n">AgentToCoordinator</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">aladin_datatypes</span><span class="o">.</span><span class="n">AgentToCoordinator</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discretization</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">(),</span>
            <span class="n">g</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discretization</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">(),</span>
            <span class="n">J</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discretization</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="p">[</span><span class="s2">&quot;J&quot;</span><span class="p">],</span>
            <span class="n">H</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">discretization</span><span class="o">.</span><span class="n">sensitivities_result</span><span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">],</span>
        <span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, AGENT-Project Associates.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>